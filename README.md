# exampleWeek2_Sort
Алгоритмы сортировки

![image](https://user-images.githubusercontent.com/77270310/179678480-593575d3-4e46-4f5b-8099-2ecbe9a67f61.png)

1.1. Задание:
- Узнать какие бывают алгоритмы сортировки

### Сортировка пузырьком
```
Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно
сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше
последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими
остаются в начале.
Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности:
он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в
конце массива.
```

### Сортировка вставками
```
Сортировка вставками - этот алгоритм разделяет оригинальный массив на сортированный и несортированный подмассивы.
Длина сортированной части равна 1 в начале и соответствует первому (левому) элементу в массиве. После этого остается итерировать массив и расширять отсортированную часть массива одним элементом с каждой новой итерацией.
После расширения новый элемент помещается на свое место в отсортированном подмассиве. Это происходит путём сдвига всех элементов вправо, пока не встретится элемент, который не нужно двигать.
```

### Сортировка выбором
```
Сортировка выбором - разделяет массив на сортированный и несортированный подмассивы. Но на этот раз сортированный подмассив формируется вставкой минимального элемента не отсортированного подмассива в конец сортированного, заменой.
В каждой итерации вы предполагаете, что первый неотсортированный элемент минимален и итерируете по всем оставшимся элементам в поисках меньшего.
После нахождения текущего минимума неотсортированной части массива вы меняете его местами с первым элементом, и он уже часть отсортированного массива.
```

### Сортировка слиянием
```
Сортировка слиянием - эффективнее, чем примеры алгоритмов сортировки выше.
Массив делится на два подмассива, а затем происходит:
- Сортировка левой половины массива (рекурсивно)
- Сортировка правой половины массива (рекурсивно)
- Слияние
В главную функцию передаются left и right – индексы подмассивов для сортировки, крайние слева и справа. Изначально они имеют значения 0 и array.length-1, в зависимости от реализации.
Основа нашей рекурсии гарантирует, что мы выйдем, когда закончим, или когда left и right встретятся друг с другом. Мы находим среднюю точку mid и рекурсивно сортируем подмассивы слева и справа от середины, в итоге объединяя наши решения.
```
![image](https://user-images.githubusercontent.com/77270310/179533401-310d29ef-eda1-4e46-895c-9c31a6c2af71.png)

### Пирамидальная сортировка
```
Пирамидальная сортировка - для понимания работы пирамидального алгоритма сортировки нужно понять структуру, на которой он основан – пирамиду.
Пирамида или двоичная куча – это дерево, в котором каждый узел состоит в отношениях с дочерними узлами. Добавление нового узла начинается с левой позиции нижнего неполного уровня.
По мере движения вниз по дереву значения уменьшаются (min-heap) или увеличиваются (max-heap). Смотрите пример max-heap:

Чтение графа сверху вниз здесь представлено слева направо. Мы добились того, что позиция дочернего элемента по отношению к k-ому элементу в массиве – 2\*k+1 и 2\*k+2 (при условии, что индексация начинается с 0). Проверьте сами!

И наоборот, для k-го элемента дочерняя позиция всегда равна (k-1)/2.

С этими знаниями вы сделаете max-heap из любого массива! Для этого проверьте каждый элемент на условие, что каждый из его дочерних элементов имеет меньшее значение.
Условие верно? Тогда меняйте местами один из дочерних элементов с родительским и повторяйте рекурсию с новым родительским элементом (он может всё ещё быть больше другого дочернего).
```
![image](https://user-images.githubusercontent.com/77270310/179536460-62c986e1-bee6-461d-a415-ae2e8ef47fe7.png)
```
Вы научились строить пирамиду из массива, все остальное гораздо проще! Поменяйте местами корень пирамиды с концом массива, и сократите массив на единицу.
Постройте кучу из сокращенного массива и повторяйте процесс:
```
![image](https://user-images.githubusercontent.com/77270310/179536502-f3c2d22e-ccf9-4786-8af7-5b440c5e8782.png)
```
И так далее.
```
![image](https://user-images.githubusercontent.com/77270310/179533349-497bb3a1-cbbf-40a5-89f0-b74a218367d8.png)

### Быстрая сортировка
```
Быстрая сортировка - Этот алгоритм состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его обычно
называют опорным. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше
опорного оказались до него, а большие или равные — после. А дальше рекурсивно применяют первые два
шага к подмассивам справа и слева от опорного значения.
```

### Шейкерная сортировка
```
Шейкерная сортировка - отличается от пузырьковой тем, что она двунаправленная: алгоритм
перемещается не строго слева направо, а сначала слева направо, затем справа налево.
```

### Сортировка расчёской
```
Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить»
элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при
пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при
«расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями,
а потом оно сужается вплоть до минимального.
Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора
уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами
будет равняться размеру массива, поделённому на 1,247. На каждом последующем шаге расстояние
будет снова делиться на фактор уменьшения — и так до окончания работы алгоритма.
```
- Сделать на каждый алгоритм отдельную функцию
- Сделать андроид-приложение в котором можно выбрать X(кол-во чисел в 
списке для сортировки), сами числа пусть будут рандомными, выбрать 
Y(алгоритм сортировки), отобразить время за которое произошла сортировка
- Поэкспериментировать на разных значениях, сравнить скорость

1.2.
- Сравнить со скоростью стандартной функции сортировки
- Добавить в приложение выбор Z (выбор структуры данных списка чисел 
для сортировки)
- Написать в комментариях к приложению инструкцию для пользователя
- Написать в комментариях к приложению список самых быстрых 
алгоритмов, с указанием входных параметров
